<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>iPad 點擊圓形綠色即中獎</title>
  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      margin: 0;
      overflow: hidden;
      background-color: #f0f0f0;
      width:100vw;
      height:100vh;
    }
  </style>
</head>
<body>
  <script>
    let circles = [];
    const circleDiameter = 150;
    const circleRadius = circleDiameter / 2;
    const friction = 0.99;
    
    // 追蹤遊戲狀態
    let isPaused = false;
    let allCirclesClicked = false;
    let clickedCount = 0;
    
    // 綠色圓形的索引，-1 表示沒有綠色圓形
    let greenCircleIndex = -1;
    
    // 暫停計時器
    let pauseStartTime = 0;
    const pauseDuration = 3000;

    // 圓形類別
    class Circle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.vx = random([-2, 2]);
        this.vy = random([-2, 2]);
        this.isClicked = false;
      }

      move() {
        this.x += this.vx;
        this.y += this.vy;
      }

      // 檢查是否與畫布邊緣碰撞並反彈
      checkWalls() {
        if (this.x + circleRadius > width) {
          this.vx *= -1;
          this.x = width - circleRadius;
        } else if (this.x - circleRadius < 0) {
          this.vx *= -1;
          this.x = circleRadius;
        }

        if (this.y + circleRadius > height) {
          this.vy *= -1;
          this.y = height - circleRadius;
        } else if (this.y - circleRadius < 0) {
          this.vy *= -1;
          this.y = circleRadius;
        }
      }

      display(index) {
        if (this.isClicked) {
          if (index === greenCircleIndex) {
            fill(183, 255, 0); 
          } else {
            fill(255, 0, 130); 
          }
        } else {
          fill(0); 
        }
        noStroke();
        ellipse(this.x, this.y, circleDiameter);
      }
    }

    // 重置遊戲狀態
    function resetGame() {
      for (let circle of circles) {
        circle.isClicked = false;
      }
      isPaused = false;
      allCirclesClicked = false;
      clickedCount = 0;
      greenCircleIndex = -1;
    }
    
    // 創建圓形
    function createCircles() {
      circles = [];
      for (let i = 0; i < 5; i++) {
        let x, y;
        let overlapping = true;
        while(overlapping) {
          // 確保圓形生成在畫布範圍內
          x = random(circleRadius, width - circleRadius);
          y = random(circleRadius, height - circleRadius);
          overlapping = false;
          for (let other of circles) {
            let d = dist(x, y, other.x, other.y);
            if (d < circleDiameter) {
              overlapping = true;
              break;
            }
          }
        }
        circles.push(new Circle(x, y));
      }
    }

    function setup() {
      // 這裡就是你修改畫布尺寸的地方
      createCanvas(1024, 640);
      createCircles();
    }

    function draw() {
      background(255);

      if (allCirclesClicked && millis() - pauseStartTime > pauseDuration) {
        resetGame();
        return;
      }

      if (!isPaused && !allCirclesClicked) {
        for (let i = 0; i < circles.length; i++) {
          for (let j = i + 1; j < circles.length; j++) {
            let circle1 = circles[i];
            let circle2 = circles[j];
            let d = dist(circle1.x, circle1.y, circle2.x, circle2.y);
            if (d < circleDiameter) {
              handleCollision(circle1, circle2);
            }
          }
        }
        
        for (let circle of circles) {
          circle.move();
          circle.checkWalls();
        }
      }

      for (let i = 0; i < circles.length; i++) {
        circles[i].display(i);
      }
    }

    function mousePressed() {
      if (allCirclesClicked) {
        resetGame();
        return;
      }

      if (isPaused) {
        for (let i = 0; i < circles.length; i++) {
          let circle = circles[i];
          let d = dist(mouseX, mouseY, circle.x, circle.y);
          
          if (d < circleRadius && !circle.isClicked) {
            circle.isClicked = true;
            clickedCount++;
            
            if (clickedCount === circles.length) {
              allCirclesClicked = true;
              pauseStartTime = millis();
            }

            if (greenCircleIndex === -1) {
              let unclickedCircles = [];
              for (let j = 0; j < circles.length; j++) {
                if (!circles[j].isClicked) {
                  unclickedCircles.push(j);
                }
              }
              if (unclickedCircles.length > 0) {
                greenCircleIndex = unclickedCircles[floor(random(unclickedCircles.length))];
              }
            }
            break;
          }
        }
        return;
      }

      for (let i = 0; i < circles.length; i++) {
        let circle = circles[i];
        let d = dist(mouseX, mouseY, circle.x, circle.y);
        
        if (d < circleRadius && !circle.isClicked) {
          isPaused = true;
          circle.isClicked = true;
          clickedCount++;
          break;
        }
      }
    }

    function handleCollision(circle1, circle2) {
      let dx = circle2.x - circle1.x;
      let dy = circle2.y - circle1.y;
      let distanceSquared = dx * dx + dy * dy;
      let distance = sqrt(distanceSquared);
      let overlap = circleDiameter - distance;
      let normalX = dx / distance;
      let normalY = dy / distance;

      circle1.x -= normalX * overlap / 2;
      circle1.y -= normalY * overlap / 2;
      circle2.x += normalX * overlap / 2;
      circle2.y += normalY * overlap / 2;
      
      let tangentX = -normalY;
      let tangentY = normalX;

      let dotProductNormal1 = circle1.vx * normalX + circle1.vy * normalY;
      let dotProductTangent1 = circle1.vx * tangentX + circle1.vy * tangentY;
      let dotProductNormal2 = circle2.vx * normalX + circle2.vy * normalY;
      let dotProductTangent2 = circle2.vx * tangentX + circle2.vy * tangentY;

      let finalNormal1 = dotProductNormal2;
      let finalNormal2 = dotProductNormal1;
      
      circle1.vx = (tangentX * dotProductTangent1 + normalX * finalNormal1) * friction;
      circle1.vy = (tangentY * dotProductTangent1 + normalY * finalNormal1) * friction;
      circle2.vx = (tangentX * dotProductTangent2 + normalX * finalNormal2) * friction;
      circle2.vy = (tangentY * dotProductTangent2 + normalY * finalNormal2) * friction;
    }
  </script>
</body>
</html>






